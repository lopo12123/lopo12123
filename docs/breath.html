<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
        <title>Breath</title>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/TweenMax.min.js'></script>

        <style>
            #svg {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }

            #path1 {
                fill: #ffcf4e;
                mix-blend-mode: multiply;
            }

            #path2 {
                fill: #ff383d;
                mix-blend-mode: multiply;
            }

            #path3 {
                fill: #0ebeff;
                mix-blend-mode: multiply;
            }
        </style>
    </head>
    <body>
        <svg id="svg" viewBox="0 0 1000 1000">
            <path id="path1"/>
            <path id="path2"/>
            <path id="path3"/>
        </svg>

        <script>
            const blob1 = createBlob({
                element: document.querySelector("#path1"),
                numPoints: 10,
                centerX: 480,
                centerY: 480,
                minRadius: 300,
                maxRadius: 350,
                minDuration: 1,
                maxDuration: 2
            });

            const blob2 = createBlob({
                element: document.querySelector("#path2"),
                numPoints: 10,
                centerX: 500,
                centerY: 500,
                minRadius: 280,
                maxRadius: 350,
                minDuration: 2,
                maxDuration: 3
            });

            const blob3 = createBlob({
                element: document.querySelector("#path3"),
                numPoints: 10,
                centerX: 520,
                centerY: 520,
                minRadius: 300,
                maxRadius: 350,
                minDuration: 1.5,
                maxDuration: 2.5
            });

            function createBlob(options) {

                const points = [];
                const path = options.element;
                const slice = (Math.PI * 2) / options.numPoints;
                const startAngle = random(Math.PI * 2);

                const tl = new TimelineMax({
                    onUpdate: update
                });

                for (let i = 0; i < options.numPoints; i++) {

                    const angle = startAngle + i * slice;
                    const duration = random(options.minDuration, options.maxDuration);

                    const point = {
                        x: options.centerX + Math.cos(angle) * options.minRadius,
                        y: options.centerY + Math.sin(angle) * options.minRadius
                    };

                    const tween = TweenMax.to(point, duration, {
                        x: options.centerX + Math.cos(angle) * options.maxRadius,
                        y: options.centerY + Math.sin(angle) * options.maxRadius,
                        repeat: -1,
                        yoyo: true,
                        ease: Sine.easeInOut
                    });

                    tl.add(tween, -random(duration));
                    points.push(point);
                }

                options.tl = tl;
                options.points = points;

                function update() {
                    path.setAttribute("d", cardinal(points, true, 1));
                }

                return options;
            }

            // Cardinal spline - a uniform Catmull-Rom spline with a tension option
            function cardinal(data, closed, tension) {

                if (data.length < 1) return "M0 0";
                if (tension == null) tension = 1;

                const size = data.length - (closed ? 0 : 1);
                let path = "M" + data[0].x + " " + data[0].y + " C";

                for (let i = 0; i < size; i++) {

                    let p0, p1, p2, p3;

                    if (closed) {
                        p0 = data[(i - 1 + size) % size];
                        p1 = data[i];
                        p2 = data[(i + 1) % size];
                        p3 = data[(i + 2) % size];

                    } else {
                        p0 = i === 0 ? data[0] : data[i - 1];
                        p1 = data[i];
                        p2 = data[i + 1];
                        p3 = i === size - 1 ? p2 : data[i + 2];
                    }

                    const x1 = p1.x + (p2.x - p0.x) / 6 * tension;
                    const y1 = p1.y + (p2.y - p0.y) / 6 * tension;

                    const x2 = p2.x - (p3.x - p1.x) / 6 * tension;
                    const y2 = p2.y - (p3.y - p1.y) / 6 * tension;

                    path += " " + x1 + " " + y1 + " " + x2 + " " + y2 + " " + p2.x + " " + p2.y;
                }

                return closed ? path + "z" : path;
            }

            function random(min, max) {
                if (max == null) {
                    max = min;
                    min = 0;
                }
                if (min > max) {
                    const tmp = min;
                    min = max;
                    max = tmp;
                }
                return min + (max - min) * Math.random();
            }
        </script>
    </body>
</html>